# -*- coding: utf-8 -*-

import os

import wx
import wx.lib.plot as plot

import sakura_gui_autogenerated
import numpy as np

import get_mda as gmda
import edge_tables as etab
import get_netcdf as gnc
import readMDA
import time
import config



RESOURCES_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'resources')
SAKURA_HOME_PATH = os.getcwd()

print 'wxPython version:', wx.__version__
print ''


# Implementing MainFrame
class SakuraBaseMainFrame( sakura_gui_autogenerated.MainFrame ):
    def __init__( self, parent ):
        self.detector_rows = 0
        self.detector_cols = 0
        sakura_gui_autogenerated.MainFrame.__init__( self, parent )

        self.pixel_ids1 = []
        self.m_FluoroUpperPanel.Layout()

        self.pixel_ids2 = []
        self.m_FluoroLowerPanel.Layout()

        self.m_DetectorPanel.Layout()
        self.m_DetectorPanel.Hide()
        # self.m_DetectorPanel.Sizer.Fit( self.m_DetectorPanel )

        #   (a) disable the "Unload" button as it attempts to delete variables from memory
        #       which are not loaded yet
        #       (enable this button after data has been loaded)
        #   (b) disable the edge selector list box
        #       (enable once data is loaded and an edge has been identified)
        #   (c) disable file selector checkList box
        #   (d) hide the Weight Factor buttons radio box
        self.m_toolBar1.EnableTool(sakura_gui_autogenerated.id_unload, False)
        self.m_listBox_Edge.Disable()
        self.m_checkList_Spectra.Disable()
        self.m_radioBox1.Hide()
        self.m_radioBox2.Hide()

        # For each panel to display spectra, generate a graphics canvas object
        self.make_canvas('canvasTopLeft', self.m_panelTopLeft)
        self.make_canvas('canvasTopRight', self.m_panelTopRight)
        self.make_canvas('canvasMuLeft', self.m_MuLeftPanel)
        self.make_canvas('canvasMuRight', self.m_MuRightPanel)
        self.make_canvas('canvasChiLeft', self.m_ChiLeftPanel)
        self.make_canvas('canvasChiRight', self.m_ChiRightPanel)
        self.make_canvas('canvasOverplotLeft', self.m_OverplotLeftPanel)
        self.make_canvas('canvasOverplotRight', self.m_OverplotRightPanel)

        # Now, specifically for the spectrum canvas with ROI setting, set the scaling and
        # bind the mouse event handler
        canvas = self.make_canvas('canvasSpectrum', self.m_SpectrumPlotPanel)
        canvas.SetXSpec('min')         # set tight x-axis limits
        canvas.SetEnableZoom(False)    # disable zoom

        # canvas.canvas.Bind(wx.EVT_PAINT, self.OnPaint_SpectrumPlotCanvas)

        self.start_pos = None
        canvas.selecting = False

        # -----------------------------------------------------------
        # Non-GUI attributes
        # -----------------------------------------------------------
        # create an empty container (list) to hold results from averaging data
        #    later on, this will be filled with instances of the "Results()" Object
        #    (see above Class definition)
        # this is adequate here as part of initialising the whole application
        # see end of event function "OnClick_Load" for first use and details
        self.results = []

        # A dictionary that can hold "Extra" PVs read from the current mda file
        self.extra_pvs = {}

        # array to hold filenames of files already processed
        #   (see end of event function "OnClick_Load" for first use and details)
        self.whichProcessed = []

        # Holds a reference to the get_mda or get_netcdf module depending on the type of
        # mda opened by the Open File dialog. Ensure that this is set from None to
        # gmda or gnc and back to None but NOT from gmda to gnc or gnc to gmda. This will
        # ensure that users don't try to process mapping mode and step mode data at the
        # same time.
        self.reader = None

        # Holds the index of the last detector pixel left-clicked by the user
        self.index_lastPixelLeftClicked = None
        self.element_frozen = False

        # Read the colourmap from a 256x3-entry text file that was generated
        # by the dump_cmap.py script. By doing this, we avoid matplotlib as a dependency
        # when it comes time to bundle Sakura for distribution.
        self.colourTable = np.loadtxt( u"resources/gist_heat.cmap" )

        # A mutex flag to disable event handling by ROI setters until initialisation
        self.roi_disable_events_mutex = True

        # config file
        self.config = config.Config()


    def make_canvas(self, canvas_name, parent_panel):
        """Create a plot canvas for a parent Panel and make it accessible as
        an attribute .canvas_name

        Arguments:
        canvas_name - string containing canvas/attribute name
        parent_panel - parent wx.Panel

        Returns:
        canvas reference

        """
        canvas = plot.PlotCanvas(parent=parent_panel)
        canvas.SetInitialSize(size=parent_panel.GetSize())
        canvas.SetEnableZoom(True)
        canvas.SetEnableGrid(True)
        canvas.SetGridColour('#CCCCCC')     # mid-grey grid
        canvas.Layout()
        setattr(self, canvas_name, canvas)
        return canvas

    def make_detector_grid_sizer(self, parent_panel, rows, cols):
        """Builds and returns a detector panel tool and assigns the four mouse
        events for every element to the four handlers.

        Arguments:
        parent_panel - a wx.Panel object reference to parent the sizer to
        rows, cols - no. of rows and cols to build

        Returns:
        The sizer object and a list of UI element ids in increasing order of element

        """
        gSizer = wx.GridSizer(rows, cols, 0, 0)

        element_ids_list = []
        # We add elements in the UI along the rows, so we have to iterate over element
        # indices in the order 0,10,20,...,1,11,21,...,79,89,99 then return the list
        # of ids reordered to correct the indexing
        ixmax = rows*cols - 1
        ixs = np.array([i*cols%ixmax for i in range(ixmax)] + [ixmax])
        for i in ixs:
            ID_PIXEL = wx.NewId()
            element_ids_list.append(ID_PIXEL)
            self.label = wx.StaticText(
                parent_panel, ID_PIXEL, label=str(i + 1),
                size=(20, 20), style=wx.ALIGN_CENTRE | wx.ST_NO_AUTORESIZE)
            gSizer.Add(self.label, 0, wx.ALIGN_CENTER | wx.ALL, 1)

            # Connect static texts (=detector pixels) to events
            self.label.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDownPixel)
            self.label.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDownPixel)
            self.label.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterPixel)
            self.label.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeavePixel)

        # reorder element ids
        element_ids_list = np.array(element_ids_list)[np.argsort(ixs)].tolist()
        return gSizer, element_ids_list

    def _get_linked_pixels(self, event):
        """Get the detector element GUI object references and the Sakura object container
        index of the element associated with the event.

        Arguments:
        event - a mouse event by which we can identify an associated detector grid element

        Returns:
        triggerPixel, linkedPixel - GUI object references of mouse triggering UI element
        index - Sakura object container index of the element

        """
        # identify which pixel triggered event
        pixelID = event.GetEventObject().GetId()
        triggerPixel = wx.FindWindowById(pixelID)

        # identify which pixel number (index) belongs to the triggering pixel
        if pixelID in self.pixel_ids1:
            index = self.pixel_ids1.index(pixelID)
            linkedID = self.pixel_ids2[index]
            linkedPixel = wx.FindWindowById(linkedID)
        elif pixelID in self.pixel_ids2:
            index = self.pixel_ids2.index(pixelID)
            linkedID = self.pixel_ids1[index]
            linkedPixel = wx.FindWindowById(linkedID)
        else:
            print 'Error in _get_linked_pixels routine: pixel ID not in detector pixel ID lists.'

        return triggerPixel, linkedPixel, index

    ############################################
    #
    # Event handlers
    #
    ############################################

    def OnCheckList_SpecSelect(self, event):
        """Spectrum and Edge choice box events (in controls area).

        """
        self.specSelec = self.m_checkList_Spectra.GetSelection()
        print 'Spectrum selected: ', self.specSelec

        # update reference to results object
        self.det = self.results[self.specSelec].det
        self.trans = self.results[self.specSelec].trans
        self.e = self.results[self.specSelec].e
        self.k = self.results[self.specSelec].k
        self.i0 = self.results[self.specSelec].i0

        # process data (dead time correction; weighting; averaging; etc)
        self.fname = self.results[self.specSelec].fname
        print 'fname: ', self.fname

        self.reaverage()

        # # get previously processed data from memory and:
        # # (1) send I0 to first plot up the top
        # self.plotSpectrum(self.e, self.trans[1],
        #                   'E  /  eV', 'I0:   I  /  cts/sec',
        #                   self.canvasTopLeft)
        #
        # # (2) send transmission data (reference foil) to plot
        # self.plotSpectrum(self.e, np.log( self.trans[2]/self.trans[3] ),
        #                   'E  / eV', 'reference:  -ln(I2/I1)  /  a.u.',
        #                   self.canvasTopRight)

        # 2. send transmission data (reference foil) to plot
        # canvasID = self.plotSpectrum(self.e,
        #                              np.log(
        #                                 self.trans[2] /
        #                                 self.trans[3]
        #                                 ),
        #                              'E  / eV',
        #                              'reference:  -ln(I2/I1)  /  a.u.',
        #                              self.canvasChiAverage)
        # self.canvasID_panelChiAverage = canvasID
        self.update_plot_displays()

        self._focus_spectrum(self.results[self.specSelec])

        self.colourPixels(1, self.results[self.specSelec].ROIaverage,
                          self.results[self.specSelec].goodPixels, scale=True)
        if self.m_radioBtn_DetInt.GetValue() == True :
            updateWhat = self.results[self.specSelec].TCRaverage
            scaleHow = True
        elif self.m_radioBtn_Correl.GetValue() == True :
            updateWhat = self.results[self.specSelec].correls
            scaleHow = False
        elif self.m_radioBtn_Weights.GetValue() == True :
            updateWhat = self.results[self.specSelec].weights
            scaleHow = False
        self.colourPixels(2, updateWhat, self.results[self.specSelec].goodPixels,
                          scale=scaleHow)

    def OnCheckList_SpecToggle(self, event):
        self.spectraChecked = self.m_checkList_Spectra.GetChecked()

    def OnList_EdgeSelect(self, event):
        select = self.m_listBox_Edge.GetStringSelection()
        parts = select.split('-')
        element = parts[0]

        transition = parts[1]
        transitionIndex = np.where(np.asarray(etab.QNTransition) == transition)[0]
        self.e0 = etab.edgeEnergy[element][transitionIndex]

        print 'new E0 = ', self.e0, 'eV'

        print 're-computing weight factors and re-averaging...'
        # Re-Process data
        self.reaverage()
        self.k = self.det[0].k

        print 'updating plot displays...'
        self.update_plot_displays()

        # # get previously processed data from memory and:
        # # 1. send I0 to first plot up the top
        # canvasID = self.plotSpectrum(self.e, self.averageMu,
        #                              'E  /  eV', 'mu(E)*d  /  a.u.',
        #                              self.canvasMuAverage)
        # self.canvasID_panelMuAverage = canvasID
        #
        # # 2. send transmission data (reference foil) to plot
        # canvasID = self.plotSpectrum(self.e,
        #                              np.log(
        #                                 self.trans[2] /
        #                                 self.trans[3]
        #                                 ),
        #                              'E  / eV',
        #                              'reference:  -ln(I2/I1)  /  a.u.',
        #                              self.canvasTopRight)
        # self.canvasID_panelChiAverage = canvasID


        # canvasID = self.plotSpectrum(
        #     self.k, self.averageChi * np.square(self.k),
        #     'k  /  A^-1', 'k^2 * chi(k)  /  a.u.',
        #                   self.canvasChiAverage)


        ## get previously processed data from memory and:
        ## 1. send I0 to first plot up the top
        # canvasID = self.plotSpectrum(self.e,
        #                              self.trans[1],
        #                              'E  /  eV', 'I0:   I  /  cts/sec',
        #                              self.canvasTopLeft)
        # self.canvasID_panelMuAverage = canvasID
        #
        ## 2. send transmission data (reference foil) to plot
        # canvasID = self.plotSpectrum(self.e,
        #                              np.log(
        #                                 self.trans[2] /
        #                                 self.trans[3]
        #                                 ),
        #                              'E  / eV',
        #                              'reference:  -ln(I2/I1)  /  a.u.',
        #                              self.canvasTopRight)
        # self.canvasID_panelChiAverage = canvasID


    def OnRightDownPixel(self, event):
        """Detector pixel event handler
        Right-clicking a detector element toggles the "goodPixels" mask value of that
        element.

        """
        clickedPixel, linkedPixel, index = self._get_linked_pixels(event)

        # if pixel was previously excluded (=index set to -1; marked grey), then
        # re-include now, otherwise exclude (by setting to -1)
        if self.results[self.specSelec].goodPixels[index] > -1:
            # exclude = set to '-1'; can be undone by user
            self.results[self.specSelec].goodPixels[index] = -1
            clickedPixel.SetBackgroundColour('grey')        # wx.Colour( 255, 0, 0 )
            linkedPixel.SetBackgroundColour('grey')
        elif self.results[self.specSelec].goodPixels[index] == -1:
            self.results[self.specSelec].goodPixels[index] = index
            # re-paint the pixels in the detector panels (because one was clicked on
            # again and is still grey)
            self.colourPixels(1, self.results[self.specSelec].ROIaverage,
                              self.results[self.specSelec].goodPixels, scale=True)
        if self.m_radioBtn_DetInt.GetValue() == True :
            updateWhat = self.results[self.specSelec].TCRaverage
            scaleHow = True
        elif self.m_radioBtn_Correl.GetValue() == True :
            updateWhat = self.results[self.specSelec].correls
            scaleHow = False
        elif self.m_radioBtn_Weights.GetValue() == True :
            updateWhat = self.results[self.specSelec].weights
            scaleHow = False
        self.colourPixels(2, updateWhat, self.results[self.specSelec].goodPixels,
                          scale=scaleHow)

        # Since a pixel was included/excluded, the average mu & chi will have changed;
        # re-compute now ("getAverage()" returns a list of arrays, i.e. [averageMu, averageChi])

        self.reaverage()
#         mu, chi = gmda.getAverage(self.results[self.specSelec].goodPixels,
#                                    self.results[self.specSelec].det)
#         self.results[self.specSelec].averageMu = mu
#         self.results[self.specSelec].averageChi = chi

        clickedPixel.Refresh()
        linkedPixel.Refresh()

    def OnLeftDownPixel(self, event):
        """left mouse button down
        Display spectrum of corresponding detector element in right-hand plot window
        and lock the Spectrum panel to show only that element.
        --- structure similar to "OnRightDownPixel"
        --- see there for more detailed comments

        """
        clickedPixel, linkedPixel, index = self._get_linked_pixels(event)

        # further action only for pixels that are not forever
        # excluded (forever excluded = -2)
        if self.results[self.specSelec].goodPixels[index] == -2:
            return

        if index == self.index_lastPixelLeftClicked:
            # same element index clicked as last time - toggle lock state
            self.element_frozen = not self.element_frozen
        else:
            self.element_frozen = True

        # Deal with previously-clicked detector element text
        if self.index_lastPixelLeftClicked != None:
            lastPixel1 = wx.FindWindowById(self.pixel_ids1[self.index_lastPixelLeftClicked])
            lastPixel2 = wx.FindWindowById(self.pixel_ids2[self.index_lastPixelLeftClicked])
            lastFont = lastPixel1.GetFont()
            lastFont.SetWeight(wx.NORMAL)
            lastPixel1.SetFont(lastFont)
            lastPixel2.SetFont(lastFont)
            lastPixel1.SetForegroundColour('black')
            lastPixel2.SetForegroundColour('black')

            lastPixel1.Refresh()
            lastPixel2.Refresh()

        self.index_lastPixelLeftClicked = index         # Remember the element index

        # Deal with currently-clicked detector element text
        currentFont = clickedPixel.GetFont()
        clickedPixel.SetForegroundColour('yellow')
        linkedPixel.SetForegroundColour('yellow')
        # Set weight of current element label
        if self.element_frozen:
            currentFont.SetWeight(wx.BOLD)
        else:
            currentFont.SetWeight(wx.NORMAL)
        clickedPixel.SetFont(currentFont)
        linkedPixel.SetFont(currentFont)

        clickedPixel.Refresh()
        linkedPixel.Refresh()

        # define 'x' and 'y' for plotting depending on toggle button state (mu/chi)
        x = self.k
        y = self.results[self.specSelec].det[index].chi * x**3
        xlabel = 'k  /  A^-1'
        ylabel = 'chi(k)*k^3  /  a.u.'
        moreY = self.results[self.specSelec].averageChi * x**3
        destination = self.canvasChiRight
        # send to second plot panel canvas used to display single detector channels
        self.plotSpectrum(x, y, xlabel, ylabel, destination, moreY=moreY)

        x = self.results[self.specSelec].e
        y = self.results[self.specSelec].det[index].roiCorrNorm
        xlabel = 'E  /  eV'
        ylabel = 'mu(E)*d  /  a.u.'
        moreY = self.results[self.specSelec].averageMu
        destination = self.canvasMuRight
        # send to second plot panel canvas used to display single detector channels
        self.plotSpectrum(x, y, xlabel, ylabel, destination, moreY=moreY)

        self._show_spectrum(index)  # Show the spectrum if it is visible in the GUI

    def OnEnterPixel(self, event):
        """mouse entering pixel --> display pixel values in status bar
        --> highlight pixel label
        --- structure similar to "OnRightDownPixel"
        --- see there for more detailed comments

        """
        pixelEntered, linkedPixel, index = self._get_linked_pixels(event)

        # read values of interest and write into status bar
        self.m_statusBar.SetStatusText(''.join([\
            'ROI average: {roi_average} cts/sec  --  ',
            'Correlation: {correlation:0.2%}  --  ',
            'TCR average: {tcr_average} cts/sec  --  ',
            'Weight: {weight:0.2f}',
            ]).format(
                roi_average=int(self.results[self.specSelec].ROIaverage[index]),
                correlation=self.results[self.specSelec].correls[index],
                tcr_average=int(self.results[self.specSelec].TCRaverage[index]),
                weight=self.results[self.specSelec].det[index].weightFactor,
            ),
            0,
        )

        # further action only for pixels that are not forever
        # excluded (i.e., =-2)
        if self.results[self.specSelec].goodPixels[index] != -2:
            # highlight font of pixel entered as "yellow"; then refresh (redraw) pixel
            pixelEntered.SetForegroundColour('yellow')
            linkedPixel.SetForegroundColour('yellow')
            pixelEntered.Refresh()
            linkedPixel.Refresh()

            # Update the mu and chi plots left panel for individual detector channels

            # Update Chi
            x = self.k
            y = self.results[self.specSelec].det[index].chi * x**3
            xlabel = 'k  /  A^-1'
            ylabel = 'chi(k)*k^3  /  a.u.'
            moreY = self.results[self.specSelec].averageChi * x**3
            destination = self.canvasChiLeft
            # send plot to canvas in corresponding panel
            self.plotSpectrum(x, y, xlabel, ylabel, destination, moreY=moreY)

            # Update Mu
            x = self.e
            y = self.results[self.specSelec].det[index].roiCorrNorm
            xlabel = 'E  /  eV'
            ylabel = 'mu(E)*d  /  a.u.'
            moreY = [self.results[self.specSelec].averageMu,
                     self.results[self.specSelec].det[index].postEdgeCurve,
                     self.results[self.specSelec].det[index].preEdgeCurve]
            destination = self.canvasMuLeft
            vlines =[(self.e0)]
            vline_ymax = 1.1 * max(self.results[self.specSelec].averageMu)
            vline_ymin = 0.9 * min(self.results[self.specSelec].averageMu)

            # send plot to canvas in corresponding panel
            self.plotSpectrum(x, y, xlabel, ylabel, destination, moreY=moreY,
                              vlines = vlines, vline_ymax = vline_ymax, vline_ymin = vline_ymin)

        if not self.element_frozen:
            self._show_spectrum(index)  # Show the spectrum if it is visible in the GUI

        # lastly, write the index of the pixel entered into an attribute
        #   (need to know when changing plot output between mu(E) and chi(k))
        self.index_lastPixelEntered = index

    def OnLeavePixel(self, event):
        """mouse leaving pixel --> revert pixel label to default colour
        --- structure similar to "OnRightDownPixel"
        --- see there for more detailed comments

        """
        pixelLeft, linkedPixel, index = self._get_linked_pixels(event)

        if self.results[self.specSelec].goodPixels[index] >= -1:
            # get info of current font used to label the pixel of interest
            currentFont = pixelLeft.GetFont()
            currentWeight = currentFont.GetWeightString()
            # if NOT set in NORMAL (e.g. BOLD face) then pixel spectrum currently
            #    displayed; do not change
            if currentWeight == 'wxNORMAL':
                pixelLeft.SetForegroundColour('black')
                linkedPixel.SetForegroundColour('black')
                pixelLeft.Refresh()
                linkedPixel.Refresh()

    def OnRadioBtn_TCR(self, event):
        """radio button events (in controls panels)"""
        self.colourPixels(2, self.results[self.specSelec].TCRaverage,
                          self.results[self.specSelec].goodPixels, scale=True)
        # display average TCR scaled to range of colour scale (256 colours)

    def OnRadioBtn_Correl(self, event):
        self.colourPixels(2, self.results[self.specSelec].correls,
                          self.results[self.specSelec].goodPixels, scale=False)
        # display correlation coefficients [0...1]; not scaled to help identify bad outliers

    def OnRadioBtn_Weights(self, event):
        self.colourPixels(2, self.results[self.specSelec].weights,
                          self.results[self.specSelec].goodPixels, scale=False)
        # display weight factors ([0...1]); not scaled to help identify bad spectra

    def OnRadioBoxBtn_WeightFactor( self, event ):
        self.reaverage()
        self.colourPixels(2, self.results[self.specSelec].weights,
                          self.results[self.specSelec].goodPixels, scale=False)
        self.m_radioBtn_Weights.SetValue(True)
        print "Weight Selection is: ", self.m_radioBox1.GetSelection(), self.m_radioBox1.GetStringSelection()

    def OnRadioBoxBtn_DeadTime( self, event ):
        print "DeadTime Selection is: ", self.m_radioBox2.GetSelection(), self.m_radioBox2.GetStringSelection()
        selection = self.m_radioBox2.GetSelection()
        self.ICRCorrParams = gmda.readICRParams(selection, self.e, 20100,
                                                self.detSize, SAKURA_HOME_PATH)
        print self.ICRCorrParams[0]
        #elif self.detSize == 36 :
        #    self.ICRCorrParams = np.loadtxt(SAKURA_HOME_PATH+"\\36eleICRcorrect.ini")

        self.reaverage()
        #self.colourPixels(2, self.results[self.specSelec].weights,
        #                  self.results[self.specSelec].goodPixels, scale=False)
        #self.m_radioBtn_Weights.SetValue(True)
        #print "Radio Box Button: ", self.m_radioBox1.GetStringSelection()


    def OnSize_MuAverageCanvas(self, event):
        size = self.m_panelTopLeft.GetSize()
        self.canvasTopLeft.SetSize(size)

    def OnSize_ChiAverageCanvas(self, event):
        size = self.m_panelTopRight.GetSize()
        self.canvasTopRight.SetSize(size)

    def OnSize_MuLeftCanvas(self, event):
        size = self.m_MuLeftPanel.GetSize()
        self.canvasMuLeft.SetSize(size)

    def OnSize_MuRightCanvas(self, event):
        size = self.m_MuRightPanel.GetSize()
        self.canvasMuRight.SetSize(size)

    def OnSize_ChiLeftCanvas(self, event):
        size = self.m_ChiLeftPanel.GetSize()
        self.canvasChiLeft.SetSize(size)

    def OnSize_ChiRightCanvas(self, event):
        size = self.m_ChiRightPanel.GetSize()
        self.canvasChiRight.SetSize(size)

    def OnSize_SpectrumPlotCanvas(self, event):
        size = self.m_SpectrumPlotPanel.GetSize()
        self.canvasSpectrum.SetSize(size)

    def OnSize_OverplotLeftCanvas(self, event):
        size = self.m_OverplotLeftPanel.GetSize()
        self.canvasOverplotLeft.SetSize(size)

    def OnSize_OverplotRightCanvas(self, event):
        size = self.m_OverplotRightPanel.GetSize()
        self.canvasOverplotRight.SetSize(size)

    ############################
    # ROI overlay event handling
    ############################

    def OnSetRoi(self, event):
        """Controls the interaction of all the ROI range setter sliders and spinboxes

        """
        # The following check enables event handling here to be disabled, which is done
        # during setup of the ROI setting bits of the UI
        if self.roi_disable_events_mutex:
            return

        # Get the current values of associated UI widgets and set roi limits in response
        low_spinner = self.m_RoiLowSpinCtrl.GetValue()
        low_slider = self.m_RoiLowSlider.GetValue()
        high_spinner = self.m_RoiHighSpinCtrl.GetValue()
        high_slider = self.m_RoiHighSlider.GetValue()

        event_name = event.EventObject.Name
        low = low_spinner
        if event_name == 'm_RoiLowSlider':
            low = low_slider
        high = high_spinner
        if event_name == 'm_RoiHighSlider':
            high = high_slider

        if low > high:
            if event_name in ['m_RoiLowSpinCtrl', 'm_RoiLowSlider']:
                low = high - 1
            else:
                high = low + 1

        self.m_RoiLowSlider.SetValue(low)
        self.m_RoiLowSpinCtrl.SetValue(low)
        self.m_RoiHighSlider.SetValue(high)
        self.m_RoiHighSpinCtrl.SetValue(high)

        self.det.roi_low = low
        self.det.roi_high = high

        self._show_spectrum()

    def OnClick_RefreshButton(self, event):
        print 'Reprocessing', self.fname

        try:
            self.SetCursor(wx.StockCursor(wx.CURSOR_WAIT))
            start_time = time.time()

            # process data (dead time correction; weighting; averaging; etc)
            self.initialProcessData(self.fname)

            print "Reprocessing took", time.time() - start_time, "seconds"
        except Exception:
            print "error processing new ROI"
        self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))

    def OnClick_LogLinButton(self, event):
        # toggle button label, state and axis scaling
        if self.m_bpLogLinButton.GetName() == 'to_lin':
            im = wx.Image(os.path.join(RESOURCES_PATH, "to_log.png"),
                          wx.BITMAP_TYPE_PNG).ConvertToBitmap()
            self.m_bpLogLinButton.SetName('to_log')
            self.canvasSpectrum.setLogScale((False, False))
        else:
            im = wx.Image(os.path.join(RESOURCES_PATH, "to_lin.png"),
                          wx.BITMAP_TYPE_PNG).ConvertToBitmap()
            self.m_bpLogLinButton.SetName('to_lin')
            self.canvasSpectrum.setLogScale((False, True))

        self.m_bpLogLinButton.SetBitmapLabel(im)
        self.Refresh()

        self._show_spectrum()

    ################################
    # End ROI overlay event handling
    ################################


    #####################################
    # Start toolbar button click handlers
    #####################################

    def OnClick_Load( self, event ):
        """Load/Save/etc buttons (in controls area)

        """
        defaultDir = self.config.read_item(group='paths', item='default_dir')
        dialog = wx.FileDialog(
            self, message="Choose a file",
            defaultDir=defaultDir,
            defaultFile="",
            wildcard='*.mda',
            style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR)

        if dialog.ShowModal() == wx.ID_OK:
            self.fname = dialog.GetPath()
            self.config.write_item(group='paths', item='default_dir',
                value=os.path.abspath(os.path.dirname(self.fname)), item_type='string')

            try:
                self.SetCursor(wx.StockCursor(wx.CURSOR_WAIT))
                start_time = time.time()

                # in spectra ListBox, remove initial default label reading "file"
                #   if present; then add new filename to ListBox
                # also: remove preceding "SR12ID01H" from label and display file No. only
                checklist_items = self.m_checkList_Spectra.GetItems()
                if checklist_items and (checklist_items[0] == 'file'):
                    self.m_checkList_Spectra.Delete(0)
                listBoxEntry = self.fname.split('.mda')[0]
                listBoxEntry = listBoxEntry.split('SR12ID01H')[1]
                self.m_checkList_Spectra.Insert(listBoxEntry, 0)

                # Set step or netCDF mode based on the 'rank' entry in the mda file
                if self.reader is None:
                    if self._mdaIsSelfContained(self.fname):
                        self.reader = gmda
                    else:
                        self.reader = gnc

                # process data (dead time correction; weighting; averaging; etc)
                print 'processing file', self.fname
                if not self.readData(self.fname):
                    return

                # get columns and rows of the detector and update the UI accordingly
                # account for non-rectangular detectors
                if self.detector_cols == 0 or self.detector_rows == 0:
                    self.detector_cols = int(np.round(np.sqrt(self.detSize)))
                    self.detector_rows = int(np.round(1.0*self.detSize / self.detector_cols))

                    # Make Upper and Lower Detector grid wx.Sizers
                    gSizer_Det1, self.pixel_ids1 = self.make_detector_grid_sizer(
                        self.m_FluoroUpperPanel, rows=self.detector_rows, cols=self.detector_cols)
                    self.m_FluoroUpperPanel.SetSizer( gSizer_Det1 )
                    self.m_FluoroUpperPanel.Layout()

                    gSizer_Det2, self.pixel_ids2 = self.make_detector_grid_sizer(
                        self.m_FluoroLowerPanel, rows=self.detector_rows, cols=self.detector_cols)
                    self.m_FluoroLowerPanel.SetSizer( gSizer_Det2 )
                    self.m_FluoroLowerPanel.Layout()


                self.getGoodPixels()


                # in the __init__ function of this Class MainFrame, we generated a list of
                #   'results' objects (empty there)
                # start to fill this list now one by one; to do so, add the latest results
                #    at position 0 (i.e., LIFO)
                # (this list is structurally similar to the "det" list of "pixel" objects in
                #    library "GMDA")
                self.results.insert(0, Results())
                self.specSelec = 0
                self.results[0].fname = self.fname
                self.results[0].goodPixels = self.goodPixels

                #
                # process the file that was just loaded
                #
                self.initialProcessData(self.fname)
                self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
                print "loading took", time.time() - start_time, "seconds"

            except Exception as e:
                print "load failed: %s" % e.message
                self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
                self.reader = None
                return

            # unhide fluorescence detector panels
            self.m_DetectorPanel.Show()

            # keep track of which file has been loaded/processed by storing filenames in
            # a list; insert items at the beginning of the list (because in corresponding
            # GUI CheckBoxList; newest item is listed up the top (i.e., FIFO)
            self.whichProcessed.insert(0, self.fname)
            print self.whichProcessed

            # in the __init__ function of this Class MainFrame, we generated a list of
            #   'results' objects (empty there)
            # fill this list now, after the first processing round, with a set of results
            self.results[0].averageMu = self.averageMu
            self.results[0].averageChi = self.averageChi
            self.results[0].TCRaverage = self.TCRaverage
            self.results[0].ROIaverage = self.ROIaverage
            self.results[0].weights = self.weights
            self.results[0].correls = self.correls
            self.results[0].trans = self.trans
            self.results[0].det = self.det
            self.results[0].i0 = self.i0
            self.results[0].k = self.k
            self.results[0].e = self.e
            self.results[0].extra_pvs = self.extra_pvs

            # we also have an attribute "self.specSelec" to consider; this attribute
            # tracks which spectrum is selected in the "self.m_checkList_Spectra"
            # checkList box by default, set this to zero (0) here; useful to always have
            # the latest spectrum loaded as the one that is active and displayed
            self.specSelec = 0

            # # now send processed data to plot window(s)
            # # 1. send I0 to first plot window up the top
            # self.plotSpectrum(self.results[0].e, self.results[0].trans[1],
            #                   'E  /  eV', 'I0  /  a.u.', self.canvasTopLeft)
            #
            #
            #
            # # 2. send reference foil sepcturm to second plot window up the top
            # canvasID = self.plotSpectrum(self.results[0].e,
            #                              np.log(
            #                                 self.results[0].trans[2] /
            #                                 self.results[0].trans[3]
            #                                 ),
            #                              'E  /  eV',
            #                              'reference:  -ln(I2/I1)  /  a.u.',
            #                              self.canvasTopRight)

            ## 2. send averaged chi(k)*k^2 to plot
            ##canvasID = self.plotSpectrum(self.results[0].k,
            ##                             self.results[0].averageChi
            ##                             * np.square(self.results[0].k),
            # 2. send reference foil sepcturm to second plot window up the top
            # canvasID = self.plotSpectrum(self.results[0].e,
            #                              np.log(
            #                                 self.results[0].trans[2] /
            #                                 self.results[0].trans[3]
            #                                 ),
            #                              'E  /  eV',
            #                              'reference:  -ln(I2/I1)  /  a.u.',
            #                              self.canvasChiAverage)
            # self.canvasID_panelChiAverage = canvasID

            self.update_plot_displays()

            # Update UI to reflect selected dataset
            self._focus_spectrum(self.results[0])

            # lastly, enable the "Unload" button, edge and file selector list boxes,
            #   Weight Factor radio box buttons, and Dead Time Correction radio box buttons
            #   to enable user choices and interaction
            if len(self.whichProcessed) - 1 == 0:
                self.m_toolBar1.EnableTool(sakura_gui_autogenerated.id_unload, True)
                self.m_listBox_Edge.Enable()
                self.m_checkList_Spectra.Enable()
                self.m_radioBox1.Show()
                self.m_radioBox2.Show()

        #clean-up
        dialog.Destroy()

    def OnClick_Save( self, event ):
        print 'Saving data...'

        try:
            print 'selected: ', self.spectraChecked
            for i in self.spectraChecked:
                print '  --> saving: ', self.results[i].fname
                print self.results[i].goodPixels

                reader_type = {gnc:'gnc', gmda:'gmda'}[self.reader]
                gmda.writeAverages(self.results[i], reader_type, self.detSize)
        except AttributeError:
            print 'Save Error: Please tick processed spectra you want to save.'

    def OnClick_Unload( self, event ):
        """clear all plot canvasses, hide detector panels and "Unload" button.

        """
        self.m_DetectorPanel.Hide()
        self.m_radioBox1.Hide()
        self.m_toolBar1.EnableTool(sakura_gui_autogenerated.id_unload, False)
        self.m_listBox_Edge.Disable()
        self.m_checkList_Spectra.Disable()

        self.canvasTopLeft.Clear()
        self.canvasTopRight.Clear()
        self.canvasMuLeft.Clear()
        self.canvasMuRight.Clear()
        self.canvasChiLeft.Clear()
        self.canvasChiRight.Clear()
        self.canvasSpectrum.Clear()

        # remove top file entry from File Listbox (NB: top one was last one loaded; LIFO)
        self.m_checkList_Spectra.Clear()

        # restore top file entry to initial state
        # self.m_checkList_Spectra.Insert('file', 0)

        # clear from memory the data from last processed dataset
        del self.det, self.detSize,
        del self.averageMu, self.averageChi
        del self.TCRaverage, self.ROIaverage
        del self.weights, self.correls
        del self.trans, self.t, self.e, self.e0, self.i0, self.edges, self.scanSize

        del self.goodPixels
        del self.k

        # clear from memory all 'results' entries in 'results list'
        self.results = []
        self.whichProcessed = []
        self.extra_pvs = {}

        # Reset step or netCDF reader mode, allowing it to be changed on the next load
        self.reader = None

    def OnClick_Exit( self, event ):
        message = 'Exiting will lose your current work. Are you sure?'
        md = wx.MessageDialog(parent=None, message=message,
            caption='Attention', style=wx.YES_NO | wx.YES_DEFAULT | wx.ICON_QUESTION)
        result = md.ShowModal()
        if result == wx.ID_YES:
            self.Destroy()

    ###################################
    # End toolbar button click handlers
    ###################################


    def OnChanging_UpperNotebook(self, event):
        '''Here we disallow switching the notebook to Spectrum view unless in netCDF mode
        by vetoing the notebook page-change event.
        '''
        if (self.m_UpperNotebook.GetCurrentPage().Name == 'm_AvgsPanel') and (
            self.reader != gnc):
            event.Veto()
        else:
            self._show_spectrum()  # Show the spectrum if it is visible in the GUI

    def OnSpinCtrl_StepSpinCtrl(self, event):
        value = self.m_StepSpinCtrl.GetValue()
        self.m_StepSlider.SetValue(value)
        self._show_spectrum()

    def OnScroll_StepSlider(self, event):
        value = self.m_StepSlider.GetValue()
        self.m_StepSpinCtrl.SetValue(value)
        self._show_spectrum()

    def colourPixels(self, whichDet, inputArray, goodPixels, scale=True):
        """Scale the colour mapping only if keyword scale is True

        Arguments:
        whichDet - detector_grid_sizer index: 1=upper, 2=lower
        inputArray - array of values indexed by pixel ids, e.g. some statistic
            based on the spectrum of the associated pixel
        goodPixels - mask array: indices of pixels to consider lie in range 0-max_px
            two special mask values -1 and -2 are used to indicate "bad" and "always bad"
            elements, respectively
        scale - Boolean. If True, use MAX and MIN values of inputArray
            to stretch colour scale

        """
        # goodPixels contains information which pixels are currently chosen to be excluded (index set to -1)
        #    these pixels should be marked grey; before compressing the the goodPixels list down (see next step)
        #    capture which pixels are to be marked grey
        mark_grey = np.where(goodPixels == -1)

        # goodPixels is designed to include index values <0 to mark bad pixels;
        #    thus, needs compressing out all indices <0 first before using in a loop
        goodPixels = np.compress(goodPixels >= 0, goodPixels)

        # set colours of Det1/2 pixels according to inputArray values
        numCols = self.colourTable.shape[0]


        if scale == True:
            # only consider values related to "goodPixels" (ie, good spectra)
            array_max = max(inputArray[goodPixels])
            array_min = min(inputArray[goodPixels])
            useArray = (numCols - 1) * (inputArray - array_min) / (array_max - array_min)
        else:
            # don't rescale
            useArray = (numCols - 1) * inputArray

        pixel_IDs = np.zeros(self.detSize)
        if whichDet == 1:          # choose which detector array to colour (Det1 or Det2)
            pixel_IDs = self.pixel_ids1
        elif whichDet == 2:
            pixel_IDs = self.pixel_ids2

        for i in goodPixels:
            colour = np.asarray(self.colourTable[int(useArray[i])]) * 255
            pixelIdToColour = wx.FindWindowById(pixel_IDs[i])
            pixelIdToColour.SetBackgroundColour(colour)
            pixelIdToColour.Refresh()
        for i in mark_grey[0] :
            pixelIdToColour = wx.FindWindowById(pixel_IDs[i])
            pixelIdToColour.SetBackgroundColour('GREY')
            pixelIdToColour.Refresh()

    def _mdaIsSelfContained(self, fname):
        """A method that checks whether we have an mda file containing fpeaks+speaks+roi
        values or whether we have that along with all MCA data in netCDF files. Just
        checks the 'rank' entry in the mda file to make a decision.

        Arguments:
        fname - mda filename

        Returns:
        True if the 'rank' entry in the mda file == 2
        False otherwise

        """
        # get the path to the netCDF files from the mda file
        mda = readMDA.readMDA(fname, verbose=False)
        return (mda[0]['rank'] == 2)

    def _focus_spectrum(self, dataset):
        """Perform UI tasks when a data series is selected.
        e.g. set the energy step range in the ROI selection window.

        """
        if isinstance(dataset.det, gnc.Detector):
            self.roi_disable_events_mutex = True

            # A netCDF dataset - set energy range, GUI ROI limits etc.
            maxval = dataset.det.steprange[-1] + 1
            self.m_StepSlider.SetMax(maxval)
            self.m_StepSpinCtrl.SetRange(1, maxval)

            # Set initial value of Energy Step widgets to max value
            self.m_StepSlider.SetValue(maxval)
            self.m_StepSpinCtrl.SetValue(maxval)

            # set ROI widget ranges
            maxval = self.det.detector_data.mca_bins
            self.m_RoiLowSlider.SetMax(maxval)
            self.m_RoiHighSlider.SetMax(maxval)
            self.m_RoiLowSpinCtrl.SetRange(1, maxval)
            self.m_RoiHighSpinCtrl.SetRange(1, maxval)

            # set ROI widget values
            self.m_RoiLowSlider.SetValue(self.det.roi_low)
            self.m_RoiHighSlider.SetValue(self.det.roi_high)
            self.m_RoiLowSpinCtrl.SetValue(self.det.roi_low)
            self.m_RoiHighSpinCtrl.SetValue(self.det.roi_high)

            self.roi_disable_events_mutex = False
        else:
            # an mda dataset - clear Spectrum canvas etc.
            self.canvasSpectrum.Clear()
            self.m_UpperNotebook.SetSelection(0)    # Select Top tab (deselect Spectrum)

    def _show_spectrum(self, index=None):
        """Shows the ROI setting spectrum

        Arguments:
        index - pixel index. If None then show the frozen index

        """
        dataset = self.results[self.specSelec]
        if index is None:
            # pick up a stored index
            if self.index_lastPixelLeftClicked is None:
                index = 0
            else:
                index = self.index_lastPixelLeftClicked
        if isinstance(dataset.det, gnc.Detector) and (
                self.m_UpperNotebook.GetSelection() == 1):
            # plot row, col, energy
            pixel_step = self.m_StepSpinCtrl.GetValue() - 1
            spectrum = self.det[index].spectrum(pixel_step)

            ymax = 1.1 * max(self.det[index].spectrum(p).max() for p in self.det.steprange)
            self.plotSpectrum(range(len(spectrum)), spectrum,
                'E_fluorescence  /  mca bin', 'I_fl  /  a.u.',
                self.canvasSpectrum, vlines=(self.det.roi_low, self.det.roi_high),
                vline_ymax=ymax, vline_ymin = 0, MCA_XRF=True)
        self.canvasSpectrum.Refresh()

    def plotSpectrum(self, x, y, xtitle, ytitle, canvas, moreY=None, vlines=None,
        vline_ymax=None, vline_ymin=None, MCA_XRF = None):
        """Send list of (x/y) tuples to plot output in destination (here called "where")

        Arguments:
        x, y - x and y data arrays
        xtitle, ytitle - axis labels
        canvas - canvas object reference
        moreY - optional additional y data series (format: list of arrays/lists)
        vlines - a list of x-coordinates to place vertical (green) lines at extending
            over the current canvas.
        vline_ymax - if vlines are supplied, supplying this determines their max
        vline_ymin - if vlines are supplied, this determines the min
        MCA_XRF - optional; used to only plot autoscaling element in the XRF/MCA panel

        Returns:
        ID of the canvas object drawn on (useful for clearing a canvas from
        outside this function; needs XXX = wx.FindWindowById(canvasID)
        at external point to find this canvas; then clear with   XXX.Clear() )

        """
        # clear corresponding canvas
        canvas.Clear()

        # zip data arrays together into list of tuples (wx.plot requires tuples)
        #   then define "line" objects to carry the data into the plot
        plotData = zip(x, y)
        line = plot.PolyLine(plotData, colour='red', width=1)
        series = [line]


        if moreY is not None:
            if len( np.shape(moreY) ) == 1 :
                plotMoreData = zip(x, moreY)
                moreLine = plot.PolyLine(plotMoreData, colour='blue', width=2)
                series.append(moreLine)
            else :
                for i in range(1, len(moreY)) :
                    plotMoreData = zip(x, moreY[i])
                    moreLine = plot.PolyLine(plotMoreData, colour='green')
                    series.append(moreLine)
                plotMoreData = zip(x, moreY[0])
                moreLine = plot.PolyLine(plotMoreData, colour='blue', width=2)
                series.append(moreLine)


        if vlines is not None:
            # Now just plot something to ensure that the autoscaling shows the full range
            ##line = plot.PolyLine([(0,1), (self.det.detector_data.mca_bins-1,1)],
            ##                     colour='white', width=1)
            if MCA_XRF is not None :
                line = plot.PolyLine([(0,1), (self.det.detector_data.mca_bins-1,1)],
                                     colour='white', width=0)
                series.append(line)

                # Plot ROI range limit lines
                # TODO is this needed?: ymax = canvas.ClientSize[1]

            if vline_ymax is not None:
                ##canvas.SetYSpec('min')         # set tight y-axis limits
                ymax = vline_ymax

            if vline_ymin is not None:
                ymin = vline_ymin

            for x in vlines:
                line_x = plot.PolyLine([(x,ymin), (x,ymax)], colour='green', width=1)
                series.append(line_x)

        ##canvas.SetXSpec('min')

        gc = plot.PlotGraphics(series, '', xtitle, ytitle)

        canvas.Draw(gc)  # , xAxis=(0,15), yAxis=(0,15))

        return canvas.GetId()   # return canvas Object ID (will be used to write
                                # into self.ATTRIBUTES after external call; see there)

    def update_plot_displays(self) :
        xlabel, ylabel = 'E  /  eV', 'I0:   I  /  cts/sec'
        self.plotSpectrum(self.e, self.results[self.specSelec].trans[1],
                          xlabel, ylabel ,
                          self.canvasTopLeft)

        xlabel, ylabel = 'E  /  eV', 'reference:  -ln(I2/I1)  /  a.u.'
        reference_spectrum = np.log( self.trans[2]/self.trans[3])
        where_inf = np.isinf(reference_spectrum)
        reference_spectrum[where_inf] = 0
        reference_spectrum = np.nan_to_num(reference_spectrum)

        self.plotSpectrum(self.e, reference_spectrum, ##.log( self.trans[2]/self.trans[3] ),
                           xlabel, ylabel ,
                           self.canvasTopRight)

        xlabelmu, ylabelmu = 'E  /  eV', 'mu(E)*d  /  a.u.'
        self.plotSpectrum(self.e, self.averageMu,
                          xlabelmu, ylabelmu, self.canvasMuLeft)

        xlabelchi , ylabelchi = 'k  /  A^-1', 'k^3 * chi(k)  /  a.u.'
        self.plotSpectrum(self.k, self.averageChi * np.square(self.k),
                          xlabelchi , ylabelchi, self.canvasChiLeft)

        moreY = [ self.results[self.specSelec].det[index].roiCorr
                  for index in np.compress(self.results[self.specSelec].goodPixels >= 0,
                                           self.results[self.specSelec].goodPixels) ]
        self.plotSpectrum(self.e, self.averageMu, xlabelmu, ylabelmu,
                          self.canvasOverplotLeft, moreY)

        moreY = [ self.results[self.specSelec].det[index].chi
                  for index in np.compress(self.results[self.specSelec].goodPixels >= 0,
                                           self.results[self.specSelec].goodPixels) ]
        self.plotSpectrum(self.k, self.averageChi, xlabelchi, ylabelchi,
                          self.canvasOverplotRight, moreY)

        return

    def set_roi_limits(self):
        pv_dict = self.extra_pvs    # extra_pvs must have been read prior to this point

        '''
        'mca1.R0LO',      # ROI low value (MCA bin no. 1..2048)
        'mca1.R0HI',      # ROI high value (MCA bin no. 1..2048)
        'dxp1.EMAX_RBV',  # full range of the MCA spectra in keV
        '''

        # TODO: get rid of the next two blocks after PVs are added to the mda file
        try:
            pv_dict['mca1.R0LO']    # attempt read
        except KeyError:
            pv_dict['mca1.R0LO'] = ('long', '', [600])
        try:
            pv_dict['mca1.R0HI']    # attempt read
        except KeyError:
            pv_dict['mca1.R0HI'] = ('long', '', [800])

        # start with this roi range
        self.det.roi_low = pv_dict['mca1.R0LO'][-1][0]
        self.det.roi_high = pv_dict['mca1.R0HI'][-1][0]

    def readData(self, whichFileToProcess):
        """Called on file load to generate required data structures.
        """
        # read in ASCII file and extract energy axis (e=data[0])
        #   transmission data (trans=data[1]), and
        #   "detector" (list of pixel objects; see "get_mda.py" for details) (det=data[2])
        # if detector size is different from existing size, skip reading
        e, trans, det = self.reader.getData(whichFileToProcess)

        if hasattr(self, 'detSize') and len(det) != self.detSize:
            print ("Error: Loaded detector size (%i) is different " +
                  "from existing size (%i)! Skipped loading.") % (len(det), self.detSize)
            return False

        # add these variables as attributes to the MainFrame Class (here as "self")
        self.det = det
        self.e = e            # energy axis in eV (conversion keV-->eV in "get_mda3.py")
        self.trans = trans

        self.detSize = len(self.det)
        self.scanSize = len(self.e)

        # For netCDF-based datasets, set the initial ROI limits from the available PVs
        if self.reader == gnc:
            self.extra_pvs = gnc.getAllExtraPVs(self.fname)
            self.set_roi_limits()
        return True

    def reaverage(self):
        # Dead Time Correction:
        gmda.detDeadCorr(self.det, self.goodPixels, self.ICRCorrParams)
        print 'xxxxxxxxxxxxxxxxxx'
        # END of DeadTimeCorrection

        # Correlation Coefficients:
        self.correls = gmda.getCorrels(self.det, self.goodPixels)
        self.colourPixels(2, self.correls, self.goodPixels, scale=False)
        self.m_radioBtn_Correl.SetValue(True)
        # END of Correlation

        # Total Countrates (averaged):
        self.TCRaverage = np.zeros(self.detSize)
        for i in self.goodPixels:
            self.TCRaverage[i] = np.mean(self.det[i].fpeaks)
        #       np.divide(np.ndarray.flatten(self.det[i].fpeaks), self.t)
        # END of TCR

        # Normalise to I0
        #   this is done in the Detector Pixel Class because:
        #   each individual spectrum needs normalising (thus, this is a "pixel" matter)
        # conceptually, normalising could also be done after applying
        # the weight factors;
        #   however, during the weighting process, we are using polynomial fits, and
        #   while those fits are still in memory, we extract something like "chi(k)";
        #   if there is structure in the data from I0, then it is better to
        #   do the normalisation to I0 *before* the fitting
        gmda.normaliseI0(self.det, self.goodPixels, self.i0)
        # END of normalise to I0

        # Weight Factors:
        # compute weight factors for each spectrum (these reflect the statistical
        #   quality of a spactrum, based on the ratio of edge step height
        #   and pre-edge background)
        self.weights = gmda.getWeightFactors(
            self.det, self.e, self.e0, self.results[self.specSelec].goodPixels,
            self.TCRaverage, self.ROIaverage,
            self.m_radioBox1.GetSelection())

        gmda.applyWeights(self.det, self.results[self.specSelec].goodPixels)
        # END of weight factors

        # Compute Average:
        # average all selected ("good") spectra using above weight factors
        mu, chi = gmda.getAverage(self.results[self.specSelec].goodPixels, self.det)
        self.averageMu = mu
        self.averageChi = chi

        self.results[self.specSelec].averageMu = mu
        self.results[self.specSelec].averageChi = chi
        self.results[self.specSelec].weights = self.weights
        print 'pixels excluded in this average: ', \
            np.where(self.results[self.specSelec].goodPixels<0)[0]
        print 'checksum - AverageMu: ', np.average(mu)
        print 'checksum - I0: ', np.average(self.i0)
        print '===================='



    def initialProcessData(self, whichFileToProcess):
        """Called on file load and ROI change.
        """
        self.t = self.trans[4][:]  # although this looks redundant it gives a separate
            # attribute for more convenient access to "t"
            # March/2013: at this stage, we are not using "self.t" anywhere; normalisation
            # to sample time is entirely done in module "gmda" ("get_mda[...].py");
            # careful also with this explicit column assignment [4]; column numbers could
            # change in "gmda"; check there!
        self.i0 = self.trans[1][:] # ! --> careful with explicit column assignment [1]

        # Average ROI countrate:
        #  (this is used for the first detector panel as information for the user)
        self.ROIaverage = np.zeros(self.detSize)
        for i in range(self.detSize):
            self.ROIaverage[i] = np.mean(self.det[i].roi)

        # set colours of Det1 pixels according to ROI average countrate
        self.colourPixels(1, self.ROIaverage, self.goodPixels, scale=True)
        # END of goodPixels

        # estimate edge energy E0:
        self.edges = gmda.getE0(self.e)
        if self.edges[2]:
            self.e0 = self.edges[2][0]
        else:
            print 'no edge found'
        #   "self.edges" is a list of lists [elements, shells, edgeEnergies]
        #   and is sorted by shells {K, L1, L2, L3};
        #   for the choice of E0, priority is given to K-shells where available,
        #   thus the choice "self.edges[2][0]"  (K = zero-th item in list edgeEnergies)
        #
        # END of e0 estimate

        # now insert all edges found up the top into the List Box (edges);
        #   for user to verify or choose from
        # also remove all other edge choices
        # highlight top priority edge just found
        temp = np.asarray([self.edges[0], np.repeat(
            '-', len(self.edges[0])), self.edges[1]]).T
        #       this generates a list of lists style of ['El','-','K']
        addListItems = []
        for i in range(len(temp)):
            print i, temp[i]
            addListItems.append(''.join(temp[i]))
        #       this loops through the list of lists, joins the
        #       sublists together, then writes them into "listItems"
        self.m_listBox_Edge.Clear()
        self.m_listBox_Edge.InsertItems(addListItems, 0)
        self.m_listBox_Edge.SetItemBackgroundColour(1, 'blue')
        self.m_listBox_Edge.SetItemForegroundColour(1, 'white')
        self.m_listBox_Edge.Refresh()

        # garbage collection
        del temp


        # Dead Time Correction:
        # using first parse on obtaining a set of GoodPixels (see "on_clickLoad"),
        #   apply dead time correction to obtain "roiCorr"
        # ( see also GMDA for input parameter into gmda.readICRParams([...]) )
        self.ICRCorrParams = gmda.readICRParams(0, self.e, 20100, self.detSize, SAKURA_HOME_PATH)
        gmda.detDeadCorr(self.det, self.goodPixels, self.ICRCorrParams)
        # END of DeadTimeCorrection

        # Correlation Coefficients:
        # as starting point, set colours of Det2 pixels according to
        #   correlation coefficients
        #   (users can choose via radio buttons what to display in Det2 pixels)
        self.correls = gmda.getCorrels(self.det, self.goodPixels)
        self.colourPixels(2, self.correls, self.goodPixels, scale=False)
        self.m_radioBtn_Correl.SetValue(True)
        # END of Correlation

        # Total Countrates (averaged):
        self.TCRaverage = np.zeros(self.detSize)
        for i in self.goodPixels:
            self.TCRaverage[i] = np.mean(self.det[i].fpeaks)
        #       np.divide(np.ndarray.flatten(self.det[i].fpeaks), self.t)
        # END of TCR

        # Normalise to I0
        #   this is done in the Detector Pixel Class because:
        #   each individual spectrum needs normalising (thus, this is a "pixel" matter)
        # conceptually, normalising could also be done after applying
        # the weight factors;
        #   however, during the weighting process, we are using polynomial fits, and
        #   while those fits are still in memory, we extract something like "chi(k)";
        #   if there is structure in the data from I0, then it is better to
        #   do the normalisation to I0 *before* the fitting
        gmda.normaliseI0(self.det, self.goodPixels, self.i0)
        # END of normalise to I0

        # Weight Factors:
        # compute weight factors for each spectrum (these reflect the statistical
        #   quality of a spactrum, based on the ratio of edge step height
        #   and pre-edge background)
        # this is useful to minimise the noise input of bad spectra into the
        #   final average
        self.reaverage()

        print 'E0 = ', self.e0, 'eV'
        # END of Compute average

        # lastly, we need to get the k-axis for chi(k) from det[0]
        #   (note: det[0] was used as a container only to transport k from "get_mda*" to here)
        self.k = self.det[0].k

    def getGoodPixels(self):
        # Good Detector Pixels:
        self.goodPixels, excludeForeverPixels = gmda.getGoodPixels(self.det, self.detSize)

        print 'exclude forever (mark red): ', excludeForeverPixels
        for i in excludeForeverPixels:
            foreverBadID1 = self.pixel_ids1[i]
            foreverBadID2 = self.pixel_ids2[i]
            foreverBadPixel1 = wx.FindWindowById(foreverBadID1)
            foreverBadPixel2 = wx.FindWindowById(foreverBadID2)

            foreverBadPixel1.SetForegroundColour('red')
            foreverBadPixel2.SetForegroundColour('red')

            foreverBadPixel1.Refresh()
            foreverBadPixel2.Refresh()

class Results(object):
    """An empty container to hold averaged data; used to store
    data while processing multiple files and to be filled in the
    Class MainFrame with data from averaging scans.

    """
    def __init__(self):
        print " instance of 'results'-object created..."
